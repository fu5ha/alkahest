use {
    crate::{
        schema::{Pack, Schema, SchemaUnpack, Unpacked},
        FixedUsize,
    },
    core::{
        convert::TryFrom,
        marker::PhantomData,
        mem::{align_of, size_of},
    },
};

#[cfg(feature = "alloc")]
use crate::schema::SchemaOwned;

/// `Schema` for runtime sized sequence of `T`.
///
/// Packed from iterator of `impl `[`Pack<T>`].
/// Unpacks into iterator of [`Unpacked<T>`]
#[cfg_attr(feature = "alloc", repr(transparent))]
pub struct Seq<T> {
    #[cfg(feature = "alloc")]
    slice: alloc::boxed::Box<[T]>,

    #[cfg(not(feature = "alloc"))]
    marker: PhantomData<[T]>,
}

#[cfg(feature = "alloc")]
impl<T> core::ops::Deref for Seq<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        &*self.slice
    }
}

#[cfg(feature = "alloc")]
impl<T> core::ops::DerefMut for Seq<T> {
    fn deref_mut(&mut self) -> &mut [T] {
        &mut *self.slice
    }
}

#[cfg(feature = "alloc")]
impl<T> Seq<T> {
    pub fn into_inner(self) -> alloc::boxed::Box<[T]> {
        self.slice
    }
}

/// Unpacked array.
/// Generated by reading using [`Seq`] schema.
#[derive(Clone, Copy)]
pub struct SeqUnpacked<'a, T> {
    offset: usize,
    len: usize,
    bytes: &'a [u8],
    marker: PhantomData<[T]>,
}

impl<'a, T> SchemaUnpack<'a> for Seq<T>
where
    T: Schema,
{
    type Unpacked = SeqUnpacked<'a, T>;
}

impl<T> Schema for Seq<T>
where
    T: Schema,
{
    type Packed = [FixedUsize; 2];

    #[inline(always)]
    fn align() -> usize {
        1 + ((align_of::<[FixedUsize; 2]>() - 1) | (<T as Schema>::align() - 1))
    }

    #[inline(always)]
    fn unpack<'a>(packed: [FixedUsize; 2], bytes: &'a [u8]) -> SeqUnpacked<'a, T> {
        assert_eq!(bytes.as_ptr() as usize % <T as Schema>::align(), 0);

        let len = usize::try_from(packed[0]).expect("Sequence is too large");
        let offset = usize::try_from(packed[1]).expect("Package is too large");

        assert_eq!(
            offset % align_of::<T::Packed>(),
            0,
            "offset {} must be aligned to {}",
            offset,
            align_of::<T::Packed>()
        );

        SeqUnpacked {
            len,
            offset,
            bytes,
            marker: PhantomData,
        }
    }
}

#[cfg(target_endian = "little")]
impl<'a, T> SeqUnpacked<'a, T> {
    /// View sequence of [`Pod`] values are a slice.
    ///
    /// Note that this function is available only on little-endian machines.
    ///
    /// [`Pod`]: bytemuck::Pod
    #[inline(always)]
    pub fn as_slice(&self) -> &[T]
    where
        T: bytemuck::Pod + Schema<Packed = T>,
    {
        bytemuck::cast_slice(&self.bytes[self.offset..][..size_of::<T>() * self.len])
    }
}

impl<'a, T> Iterator for SeqUnpacked<'a, T>
where
    T: Schema,
{
    type Item = Unpacked<'a, T>;

    #[inline]
    fn next(&mut self) -> Option<Unpacked<'a, T>> {
        if self.len == 0 {
            None
        } else {
            assert_eq!(self.offset % align_of::<T::Packed>(), 0);

            let item = *bytemuck::from_bytes(&self.bytes[self.offset..][..size_of::<T::Packed>()]);
            self.offset += size_of::<T::Packed>();
            self.len -= 1;
            Some(T::unpack(item, self.bytes))
        }
    }

    #[inline(always)]
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> ExactSizeIterator for SeqUnpacked<'a, T>
where
    T: Schema,
{
    #[inline(always)]
    fn len(&self) -> usize {
        self.len
    }
}

impl<I, T> Pack<Seq<T>> for I
where
    T: Schema,
    I: IntoIterator,
    I::IntoIter: ExactSizeIterator,
    I::Item: Pack<T>,
{
    #[inline]
    fn pack(self, offset: usize, output: &mut [u8]) -> ([FixedUsize; 2], usize) {
        debug_assert_eq!(
            output.as_ptr() as usize % <Seq<T> as Schema>::align(),
            0,
            "Output buffer is not aligned"
        );

        debug_assert_eq!(
            offset % <Seq<T> as Schema>::align(),
            0,
            "Offset is not aligned"
        );

        let iter = self.into_iter();
        let len = iter.len();

        let len32 = u32::try_from(len).expect("Sequence is too large");
        let offset32 = u32::try_from(offset).expect("Offset is too large");

        let packed_size = size_of::<T::Packed>();

        let item_align_mask = T::align() - 1;
        let mut used = packed_size * len;
        used = (used + item_align_mask) & !item_align_mask;

        let mut off = 0;
        for item in iter {
            let aligned = (used + (<T>::align() - 1)) & !(<T>::align() - 1);
            let (item_packed, item_used) = item.pack(offset + aligned, &mut output[aligned..]);
            output[off..][..packed_size].copy_from_slice(bytemuck::bytes_of(&item_packed));
            used = aligned + item_used;
            off += packed_size;
        }

        ([len32, offset32], used)
    }
}

#[cfg(feature = "alloc")]
impl<T> SchemaOwned for Seq<T>
where
    T: SchemaOwned,
{
    fn to_owned_schema<'a>(unpacked: SeqUnpacked<'a, T>) -> Seq<T> {
        Seq {
            slice: unpacked.map(|item| T::to_owned_schema(item)).collect(),
        }
    }
}
